# VK → Telegram бот: проектная записка

## Назначение
- Автокопирование новых постов из сообщества ВК в Telegram-канал с сохранением текста, ссылок, эмодзи, медиа (фото/видео), опросов.
- Автономная работа на сервере: восстановление после сбоев, логирование, уведомление владельца о критических ошибках в личку Telegram.
- Минимум зависимостей, приоритет производительности (async I/O).

## Рекомендуемый стек
- Python 3.11+ (asyncio, logging, dataclasses/pathlib/json для базовых задач).
- HTTP-клиент: `httpx` (async, HTTP/2) или стандартный `aiohttp`; можно заменить на `urllib/request` + `asyncio.to_thread`, но httpx проще и легковесен.
- Без лишних ORM/больших фреймворков. Для конфигов — чтение `os.environ` (без обязательного `python-dotenv`).
- Форматирование данных: стандартный `html`/`urllib.parse` для экранирования, без внешних шаблонизаторов.
- Локальное состояние: маленький файл JSON/SQLite через stdlib `sqlite3`.
- Деплой: systemd unit или Docker (по необходимости), без тяжелых зависимостей.
- Источники/приёмники по умолчанию: сообщество ВК `club231800979` (owner_id = -231800979), Telegram-канал `https://t.me/+q_qsapnAmYozZmFi`.

## Токены и права
- VK: групповой сервис-токен с правами `wall`, `photos`, `video` (и `docs`, если понадобятся документы), `groups` для Long Poll. Минимизировать scope.
- Telegram: токен бота (`BOT_TOKEN`), ID канала (`CHANNEL_ID`, формат `-100...`), ID владельца для уведомлений (`OWNER_ID`).
- Хранение в окружении/секретах; не логировать токены.

## Потоки данных (высокоуровнево)
1) ВК Long Poll следит за событием `wall_post_new`.
2) Новое событие → нормализация (текст, вложения, опрос).
3) Медиапайплайн: получение лучших доступных размеров фото; видео — ссылка/прямое скачивание (если возможно); опрос — маппинг в Telegram poll.
4) Отправка в Telegram: текст + медиа (media group) + poll (отдельным запросом).
5) Запись `last_post_id` (или `post_hash`) для дедупликации.
6) Логи → файл + stdout; критические ошибки → личка владельца.

## Базовый сценарий нового поста (happy-path)
1) Long Poll получил `wall_post_new`.
2) Проверить, что `post_type` допустим (`post`/`copy`), не `suggest`/`postpone`, и что `post_id` не обработан.
3) Нормализовать текст/медиа/опросы/перепосты в единый payload.
4) Если включён режим модерации — отправить предпросмотр в личку модератору с кнопками "Одобрить/Отклонить". При одобрении → публикация в канал; при отклонении — лог и отметка в состоянии. Если модерация выключена — сразу отправить в канал. Длинные тексты разбить. Медиа ≥2 — `sendMediaGroup`, иначе текст/`sendPhoto`/`sendVideo`; опрос — `sendPoll` отдельным запросом.
5) Сохранить в состоянии: `last_post_id`, `ts`, `processed_post_ids`, при наличии — `post_id -> tg_message_ids` (для возможного редактирования), статус модерации (`pending/approved/rejected`), `moderation_token` для callback.
6) Зафиксировать успех в логе; при ошибке — ретрай, потом уведомление владельца.

## Взаимодействие с VK API
- Long Poll для групп: `groups.getLongPollServer` → подписка на `wall_post_new`. Периодически обновлять сервер/ключ (`groups.getLongPollServer` раз в ~20-30 минут или при ошибке ключа).
- Запросы Long Poll: GET `https://{server}?act=a_check&key=...&ts=...&wait=25`.
- Параметры события `wall_post_new`: `post_id`, `text`, `attachments`, `copy_history` (перепосты), `owner_id`, `from_id`, `is_favorite`, `post_type`.
- Резервный fallback: периодический pull `wall.get` с фильтром `owner_id=<group_id>` и `count=5` для восстановления после рестарта.
- Ретраи на сетевые ошибки: экспоненциальная задержка с джиттером (stdlib без сторонних libs).
- Ограничения: уважать rate-limit ВК (3 запроса/сек для метода). Кэшировать `groups.getLongPollServer` результаты.

## Нормализация контента
- Текст: оставить как есть, HTML-экранирование перед отправкой в Telegram (`parse_mode=HTML`) или MarkdownV2 с экранированием спецсимволов.
- Ссылки/иконки: эмодзи перенаправлять напрямую; ссылки в тексте оставить (телеграм сам превьюит).
- Фото: выбирать максимальный размер из `photo.sizes`; при >1 фото — отправлять как media group (`sendMediaGroup`), при 1 — `sendPhoto`.
- Видео:
  - Если вложение содержит `player`/`url` на mp4 и размер небольшой (<50 МБ) — можно скачать и отправить `sendVideo`.
  - Иначе — отправить текстовую ссылку на VK видео + превью (если возможно `photo` в `video.image`).
- Опросы: если `poll` присутствует, отправлять через `sendPoll(question, options, is_anonymous)` отдельным сообщением. Ограничения Telegram: макс 10 опций, 255 символов на опцию.
- Перепосты (`copy_history`): включать текст оригинала + ссылку на источник; медиа из перепоста — объединять, если нужно.
- Неизвестные вложения (docs/audio): выводить ссылкой и пометкой "[Неподдерживаемое вложение]".

## Взаимодействие с Telegram API
- Базовые методы: `sendMessage`, `sendPhoto`, `sendMediaGroup`, `sendVideo`, `sendPoll`, `sendDocument` (для fallback).
- Формат отправки:
  - Текст + ссылки: `parse_mode=HTML`, экранировать `<>&`.
  - Медиагруппа: список объектов `{type: photo|video, media: file_id|url, caption?}`; caption только у одного элемента.
- Ограничения: 4096 символов в сообщении; если текст длиннее — разбить на части (размер <=3000 с запасом на media captions).
- Ошибки Telegram: ловить 429 (`retry_after`), 400 (неправильный контент), 403 (нет доступа к каналу) → уведомление владельцу.

## Состояние и дедупликация
- `state.db` (sqlite) или `state.json`: `last_post_id`, `last_ts`, `processed_post_ids` (ограниченный размер, ring-buffer), `post_id -> tg_message_ids` для возможной правки сообщений.
- При старте: подгрузить `wall.get` за последние N постов, отфильтровать уже отправленные по `post_id`. Восстановить `ts` для долгого опроса.
- Idempotency: перед отправкой проверять, что `post_id` не обработан и `is_pinned`/`post_type` != `suggest`.
- Редактирование постов: при повторном событии с тем же `post_id` (например, `wall_post_edit`, либо повторный `wall_post_new`) — сравнить хэш (текст+список вложений). Если тот же — пропустить. Если изменён — опционально обновить ранее отправленное сообщение через `editMessageText`/`editMessageCaption`; иначе (простой режим) — пропустить повторную отправку, логировать факт изменения.
- Модерация: хранить pending-решения по `post_id` с `moderation_token` (случайный UUID). При получении callback от модератора проверять токен и статус, чтобы не публиковать повторно.

## Логи и уведомления
- Логи: stdout + ротация файла (например, `logs/bot.log` через `logging.handlers.RotatingFileHandler`, maxBytes ~5MB, backupCount 3).
- Формат: `%(asctime)s %(levelname)s %(name)s %(message)s`.
- Критические ошибки: отправка владельцу в личку Telegram (`sendMessage` на `OWNER_ID`) с укороченным стеком и идентификатором события.
- Метрики (по желанию): считать количество обработанных постов, медиа, ошибок; выводить в логи.

## Развертывание и автономность
- systemd unit (пример): `Restart=on-failure`, `RestartSec=5`, `EnvironmentFile=/etc/botvktg.env`, `WorkingDirectory=/opt/botvktg`, `ExecStart=/opt/botvktg/venv/bin/python -m bot`.
- Health-check: периодический "я жив" лог или сообщение владельцу раз в сутки; watchdog таймер systemd.
- Docker (опционально): slim-образ `python:3.11-slim`, не тянуть лишнее (build args `--no-cache-dir`).
- Часовой пояс/локаль: фиксировать TZ в контейнере/systemd.

## Минимизация зависимостей
- Обязательные: `httpx` (или `aiohttp`) для HTTP, всё остальное — stdlib.
- Опционально: `pydantic` для валидации схем (можно заменить на ручные проверки), `python-dotenv` для удобства локальной разработки.
- Без тяжелых фреймворков (Django/FastAPI) — не требуется сервер, Long Poll работает через исходящие запросы.

## Расширение: парсинг новостей https://www.econ.msu.ru/alumni/
- Цель: дополнительно собирать свежие новости alumni и публиковать в TG-канал (через ту же модерацию, без дублей).
- Список: парсить блоки `.aef_news_text` / `h3.news_text a` на главной, дата из `.title_text .date`, заголовок и относительная ссылка.
- Деталка: `https://www.econ.msu.ru` + относительная ссылка; парсить основной текст (очистить HTML) и изображения (`<img>` и ссылки на `raw.php`), конвертировать пути в абсолютные URL.
- Дедуп: ключ — полный URL новости. Хранить `news_seen` в state. При старте/refresh брать последние N, фильтровать уже опубликованные.
- Отправка: текст (дата + заголовок + URL) + фото (до 10 в медиагруппе; остальные — ссылками). Видео/доки — ссылкой.
- Обновление: отдельный воркер с периодическим опросом (например, каждые 10–15 минут) + ручная кнопка «Обновить посты» запускает проверку новостей.
- Ошибки: при 5 одинаковых ошибках парсинга/сети — уведомление владельцу и остановка воркера.

## Тестирование и проверки
- Юнит-тесты: парсинг/нормализация вложений (фото, видео, poll, текст >4096), экранирование HTML, дедупликация.
- Интеграционные (мокаем HTTP): успешный `wall_post_new` → вызов Telegram API в правильной последовательности; обработка 429/502 с ретраями.
- Локальный dry-run: режим "log-only" без отправки в Telegram.
- Нагрузочный: прогнать 50-100 фейковых событий подряд, убедиться в отсутствии утечек и превышения rate-limit.
- Дубликаты/редакты: тесты на повторное получение события с тем же `post_id`, сравнение хэша, убедиться в отсутствии повторной отправки.
- Новости сайта: юниты на парсинг списка и детальной страницы (текст+картинки), дедуп по URL, корректное форматирование ссылок без лишних символов.

## Границы и риски
- VK видео может требовать авторизации/DRM — тогда только ссылка/превью.
- Telegram media group запрещает смешивать слишком большие видео/документы — нужна проверка размеров.
- Публичные ссылки в тексте могут поломать HTML-parse — важно экранировать.
- Длительные неудачи long poll → fallback по `wall.get` чтобы не пропускать посты.

## Качество кода и процессы
- Стиль: полностью типизированный код (PEP 484), проверка `mypy` (минимальные stubs), линтер `ruff`/`flake8`, форматирование `black`/`ruff format` (опционально, но желательно).
- Архитектура: тонкие клиенты (`vk_client`, `tg_client`), чистые функции нормализации без I/O для лёгкого тестирования, pipeline-оркестратор.
- Трассировка: детальные DEBUG-логи на этапах получения события, нормализации, отправки. INFO — успешные операции; ERROR — с trace-id и усечённым стеком; WARN — ретраи/деградации.
- Инварианты: явные проверки размеров медиа/лимитов текста, ассерты/guard clauses с понятными сообщениями.
- Тестирование в процессе: быстрые юниты на парсер и дедупликацию; контрактные тесты с моками HTTP; режим `--dry-run` для ручной проверки без отправки.
- Обслуживание: health-лог раз в N минут, алерт владельцу при >N подряд неудачах или при дрейфе `ts`.
- Рабочий цикл для экономии времени: (1) написать тест/фикстуру события VK, (2) реализовать нормализацию, (3) прогнать юниты+ruff+mypy, (4) локальный `--dry-run` с реальным `wall.get`, (5) интеграционный тест с моками TG, (6) деплой на stage/systemd и наблюдение логов 5-10 минут.

## Режим модерации (одобрение перед публикацией)
- Конфиг: `MODERATION_MODE` (`required`/`off`). В режиме `required` все новые посты сначала уходят модератору (OWNER_ID) в личку.
- Предпросмотр модератору: отправить текст и медиа. Если медиа >1 — `sendMediaGroup` в личку, caption только у одного из элементов. Опрос — через `sendPoll` (анонимный/публичный по свойствам ВК).
- Кнопки: inline-кнопки с callback_data вида `approve:{token}` и `reject:{token}` (token — UUID, привязан к post_id). Проверять, что callback пришёл от модератора.
- Публикация: при approve — отправить в канал по основному пайплайну, сохранить `tg_message_ids`, отметить статус `approved`. При reject — статус `rejected`, опционально уведомить, логи.
- Дедупликация: если событие приходит повторно, но уже есть `approved`+`post_id` — не публиковать заново. Если `pending` и текст/вложения не изменились — не дублировать предпросмотр. Если изменились — можно заново сформировать предпросмотр и инвалидировать старый token (опционально).
- Таймаут (опционально): если нет ответа модератора N минут — напомнить в личку или автопубликовать/отклонять по конфигу.
